#!/usr/bin/env python3

import os
import sys
import shutil
import functools
import http.server
import urllib.request

import git


SITE_URL = 'https://eyqs.ca'
REPO_REMOTE = 'origin'
BUILD_BRANCH = 'gh-pages'
SERVER_PORT = 8080

REPO_ROOT = '/home/eugeneyqshen/web'
BUILD_DIR = '_site'
BLOG_DIR = 'blog'
ASSETS_DIR = 'assets'
INDEX_FILE = 'index.html'
BUILD_PATH = os.path.join(REPO_ROOT, BUILD_DIR)

ARCHIVE_URL = 'http://web.archive.org/save'
ARCHIVED_PAGES = ['about', 'blog', 'cakes', 'documents', 'sitemap']
ARCHIVED_POSTS = ['2001-first-post', '2002-ubcs-cpen', '2003-japn-trans']



def get_name(name):
    return os.path.splitext(name)[0]

def get_extension(name):
    return os.path.splitext(name)[1]

def strip_repo_root(path):
    return os.path.relpath(path, REPO_ROOT)

def print_progress(message, func):
    print(f'{message}...', end='\r', flush=True)
    output = func()
    if type(output) == tuple:
        output = output[0]
    print(f'{message}: {output.strip()}', flush=True)


def create_directory(*args):
    directory = os.path.join(BUILD_PATH, *args)
    if not os.path.exists(directory):
        print_progress('Creating directory', lambda: (
                f'{strip_repo_root(directory)}/', os.mkdir(directory)))
    return directory


def generate_page(src_path, dest_path):

    shutil.copy(src_path, dest_path, follow_symlinks=False)
    return f'{strip_repo_root(src_path)} -> {strip_repo_root(dest_path)}'


def copy_directory(src_dir='', dest_dir=None):

    if dest_dir is None:
        dest_dir = src_dir
    create_directory(dest_dir)

    with os.scandir(os.path.join(REPO_ROOT, src_dir)) as it:
        for entry in it:
            if get_extension(entry.name) == '.html':
                entry_dir = create_directory(dest_dir, get_name(entry.name))
                print_progress('Generating page', lambda: (generate_page(
                        entry.path,
                        os.path.join(entry_dir, INDEX_FILE)
                )))



def archive():

    print_progress('Archiving index', lambda: ('/',
            urllib.request.urlopen(f'{ARCHIVE_URL}/{SITE_URL}/')))

    for page in ARCHIVED_PAGES:
        page_url = f'{SITE_URL}/{page}'
        print_progress('Archiving page', lambda: (page,
                urllib.request.urlopen(f'{ARCHIVE_URL}/{page_url}/')))

    for post in ARCHIVED_POSTS:
        post_url = f'{SITE_URL}/{BLOG_DIR}/{post}'
        print_progress('Archiving post', lambda: (post,
                urllib.request.urlopen(f'{ARCHIVE_URL}/{post_url}/')))


def build():

    clean()
    copy_directory()
    print_progress('Copying assets directory', lambda: (f'{ASSETS_DIR}/',
            shutil.copytree(os.path.join(REPO_ROOT, ASSETS_DIR),
                    os.path.join(BUILD_PATH, ASSETS_DIR))))


def clean():

    if os.path.exists(BUILD_PATH):
        print_progress('Removing build directory',
                lambda: (f'{BUILD_DIR}/', shutil.rmtree(BUILD_PATH)))
    else:
        print(f'Build directory does not exist: {BUILD_DIR}/')


def push():

    repo = git.Repo(REPO_ROOT)
    print_progress('Pushing to remote origin',
            lambda: repo.remotes.origin.push()[0].summary)
    print_progress('Pushing subtree to production',
            lambda: repo.git.subtree('push',
                    REPO_REMOTE, BUILD_BRANCH, prefix=BUILD_DIR))


def serve():

    print(f'Serving website at http://localhost:{SERVER_PORT}/')
    server_address = ('', SERVER_PORT)
    request_handler = functools.partial(
            http.server.SimpleHTTPRequestHandler,
            directory=BUILD_PATH
    )
    http.server.HTTPServer(server_address, request_handler).serve_forever()



def bad_input():
    print('Usage: ./web [archive|build|clean|push|serve]')
    exit(1)

if __name__ == '__main__':

    if len(sys.argv) != 2:
        bad_input()

    os.chdir(REPO_ROOT)
    if sys.argv[1] == 'archive':
        archive()
    elif sys.argv[1] == 'build':
        build()
    elif sys.argv[1] == 'clean':
        clean()
    elif sys.argv[1] == 'push':
        push()
    elif sys.argv[1] == 'serve':
        serve()
    else:
        bad_input()
